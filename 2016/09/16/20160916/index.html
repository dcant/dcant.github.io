<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>dlsym加载动态链接库进阶使用 | Talk is cheap, but I need it.</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/very-simple.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><!-- include the sidebar--><!-- include ./includes/sidebar.jade--><!-- Blog title and subtitle--><header><div class="container header"><a id="logo" href="/." class="title">Talk is cheap, but I need it.</a><span class="subtitle">dcant</span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div></header><!-- use checkbox hack for toggle nav-bar on small screens--><input id="menu" type="checkbox"><!-- Navigation Links--><nav id="nav"><div class="container"><a href="/" class="sidebar-nav-item active">主页</a><a href="/archives" class="sidebar-nav-item">归档</a><a href="/about" class="sidebar-nav-item">简录</a></div></nav><div id="header-margin-bar"></div><!-- gallery that comes before the header--><div class="wrapper"><div class="container post-header"><h1>dlsym加载动态链接库进阶使用</h1></div></div><div class="wrapper"><div class="container meta"><div class="post-time">2016-09-16</div><div class="post-tags"><a class="post-tag-link" href="/tags/C/">C++</a>/<a class="post-tag-link" href="/tags/dlsym/">dlsym</a>/<a class="post-tag-link" href="/tags/动态链接库/">动态链接库</a></div></div></div><article><div class="container post"><blockquote>
<p>本文为”C++ dlopen mini HOWTO”译文，讲解C++中使用dlsym的方法。  </p>
</blockquote>
<p><b>1 问题</b><br>有时你可能需要在运行时加载库（用库中的函数），这种情况多数发生在你需要为你的程序编写某种插件或者模块架构。<br>在C语言中加载库非常容易（调用dlopen，dlsym，dlclose即可），而C++中则有一点点复杂。动态加载C++库的难点部分原因是由于名字改编（name mangling），部分原因为dlopen API是由C开发的，因此没有提供合适的方式加载类。<br>在解释如何在C++中加载库之前，让我们通过详细地了解名字改编（name mangling）机制来更好地分析问题。我推荐你阅读关于名字改编（name mangling）的解释，因为它会帮助你理解问题是怎样产生的以及如何解决它即使你可能对它并不感兴趣。  </p>
<p><b>1.1 名字改编</b><br>在每一个C++程序（库或目标文件）中，所有非静态函数都以符号的形式呈现在二进制中。这些符号是在程序，库或目标文件中唯一地标识一个函数的特殊文本字符串。<br>在C语言中，符号名与函数名相同：符号strcpy即函数strcpy等等，这主要是由于在C语言中任意两个非静态函数名都不同。<br>由于C++允许重载（不同的函数有相同的名字但是参数不同）并且有很多C没有的特性——如类，成员函数，异常规范等——导致并不能简单地利用函数名作为符号名。为了解决这个问题，C++采用了名字改编机制，该机制将函数名和所有必需信息（如参数数量和大小）转换为某种只有编译器可以理解的奇怪字符串。例如foo改编后的名字可能看起来像foo@4%6^，甚至可能并不包含foo。<br>名字改编机制存在的问题在于C++标准并没有定义名字改编规则，因此每个编译器以各自的方式改编名字。有些编译器甚至不同版本间使用的改编算法都不相同（比如g++2.x和3.x）。即使你用清楚你特定编译器改编名字规则（因此可以通过dlsym加载函数），极有可能仅对你的编译器有效，而且可能在下一版本就又不能使用了。  </p>
<p><b>1.2 类</b><br>dlopen API的另一个问题在于只能加载函数。但是在C++库中你可能经常需要暴露的是一个类供程序使用。显然，如果要使用这个类你需要创建一个该类的实例，但是这并不能很容易地实现。  </p>
<p><b>2 解决办法</b>  </p>
<p><b>2.1 extern “C”</b><br>C++中有一个特殊的关键字用于声明一个与C绑定的函数：extern “C”。以extern “C”形式声明的函数函数名即符号名，就像C函数一样。因此只有非成员函数才可以用extern “C”声明，并且不能被重载。<br>尽管有较严厉的限制，但由于通过extern “C”方式声明的函数可以像C函数一样用dlopen动态加载，因此非常有用。<br>这并不意味着以extern “C”修饰的函数并不能包含C++代码，一个这样的函数可以是一个完全C++特性，包含任意参数类型。  </p>
<p><b>2.2 加载函数</b><br>在C++中，函数像在C中一样通过dlsym加载。你想要加载的函数必须用extern “C”修饰以避免名字被改编。  </p>
<p>Example 1.加载函数<br>main.cpp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;dlfcn.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    using std::cout;</span><br><span class="line">    using std::cerr;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;C++ dlopen demo\n\n&quot;;</span><br><span class="line"></span><br><span class="line">    // open the library</span><br><span class="line">    cout &lt;&lt; &quot;Opening hello.so...\n&quot;;</span><br><span class="line">    void* handle = dlopen(&quot;./hello.so&quot;, RTLD_LAZY);</span><br><span class="line"></span><br><span class="line">    if (!handle) &#123;</span><br><span class="line">        cerr &lt;&lt; &quot;Cannot open library: &quot; &lt;&lt; dlerror() &lt;&lt; &apos;\n&apos;;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // load the symbol</span><br><span class="line">    cout &lt;&lt; &quot;Loading symbol hello...\n&quot;;</span><br><span class="line">    typedef void (*hello_t)();</span><br><span class="line"></span><br><span class="line">    // reset errors</span><br><span class="line">    dlerror();</span><br><span class="line">    hello_t hello = (hello_t) dlsym(handle, &quot;hello&quot;);</span><br><span class="line">    const char *dlsym_error = dlerror();</span><br><span class="line">    if (dlsym_error) &#123;</span><br><span class="line">        cerr &lt;&lt; &quot;Cannot load symbol &apos;hello&apos;: &quot; &lt;&lt; dlsym_error &lt;&lt; &apos;\n&apos;;</span><br><span class="line">        dlclose(handle);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // use it to do the calculation</span><br><span class="line">    cout &lt;&lt; &quot;Calling hello...\n&quot;;</span><br><span class="line">    hello();</span><br><span class="line"></span><br><span class="line">    // close the library</span><br><span class="line">    cout &lt;&lt; &quot;Closing library...\n&quot;;</span><br><span class="line">    dlclose(handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>hello.cpp<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; void hello() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;hello&quot; &lt;&lt; &apos;\n&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数hello在hello.cpp中以extern “C”形式定义，在main.cpp中通过dlsym加载。函数必须用extern “C”修饰否则我们就不知道它的符号名。  </p>
<p>有两种形式的extern “C”声明，一种如上所示的形式，另一种是extern “C” {…}这种以大括号括起来的形式。第一种形式是外部链接和C语言链接的声明，第二种只影响语言链接。以下两种声明是等价的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; int foo;</span><br><span class="line">extern &quot;C&quot; void bar();</span><br></pre></td></tr></table></figure></p>
<p>和<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">    extern int foo;</span><br><span class="line">    extern void bar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于通过带extern和不带extern声明的函数是一样的，因此只要不声明变量就不会有问题。如果你声明变量，请记住：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; int foo;</span><br></pre></td></tr></table></figure></p>
<p>和<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">    int foo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>是不同的。  </p>
<p><b>2.3 加载类</b><br>由于我们需要的是一个类实例而不是一个指向函数的指针，因此加载类有点困难。<br>我们不能通过new关键字来创建一个类实例，因为类并没有在可执行文件中定义，在某种情况下我们甚至并不知道它的名字。<br>我们可以通过多态的方式解决这个问题。在可执行文件中定义带需成员的基类、接口类，在模块中定义继承、实现类。通常来讲，接口类是抽象类（包含纯需函数的类为抽象类）。<br>由于动态加载类通常用于插件式开发——需暴露一个明确定义的接口——因此我们必须要定义接口以及继承的实现类。<br>接下来，我们将定义两个帮助函数，即类工厂函数。其中一个函数创建一个类的实例并返回指向该实例的指针，另一个函数接受通过类工厂函数创建的指向类实例的指针并销毁它。这两个函数均通过extern “C”修饰。<br>像加载函数hello一样通过dlsym加载这两个工厂函数即可使用模块中的类；然后我们就可以创建销毁任意多的实例。  </p>
<p>示例2：加载类<br>这里我们使用一个通用的polygon类作为接口，继承类triangle作为实现。<br>main.cpp  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;polygon.hpp&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;dlfcn.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    using std::cout;</span><br><span class="line">    using std::cerr;</span><br><span class="line"></span><br><span class="line">    // load the triangle library</span><br><span class="line">    void* triangle = dlopen(&quot;./triangle.so&quot;, RTLD_LAZY);</span><br><span class="line">    if (!triangle) &#123;</span><br><span class="line">        cerr &lt;&lt; &quot;Cannot load library: &quot; &lt;&lt; dlerror() &lt;&lt; &apos;\n&apos;;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // reset errors</span><br><span class="line">    dlerror();</span><br><span class="line"></span><br><span class="line">    // load the symbols</span><br><span class="line">    create_t* create_triangle = (create_t*) dlsym(triangle, &quot;create&quot;);</span><br><span class="line">    const char* dlsym_error = dlerror();</span><br><span class="line">    if (dlsym_error) &#123;</span><br><span class="line">        cerr &lt;&lt; &quot;Cannot load symbol create: &quot; &lt;&lt; dlsym_error &lt;&lt; &apos;\n&apos;;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    destroy_t* destroy_triangle = (destroy_t*) dlsym(triangle, &quot;destroy&quot;);</span><br><span class="line">    dlsym_error = dlerror();</span><br><span class="line">    if (dlsym_error) &#123;</span><br><span class="line">        cerr &lt;&lt; &quot;Cannot load symbol destroy: &quot; &lt;&lt; dlsym_error &lt;&lt; &apos;\n&apos;;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // create an instance of the class</span><br><span class="line">    polygon* poly = create_triangle();</span><br><span class="line"></span><br><span class="line">    // use the class</span><br><span class="line">    poly-&gt;set_side_length(7);</span><br><span class="line">    cout &lt;&lt; &quot;The area is: &quot; &lt;&lt; poly-&gt;area() &lt;&lt; &apos;\n&apos;;</span><br><span class="line"></span><br><span class="line">    // destroy the class</span><br><span class="line">    destroy_triangle(poly);</span><br><span class="line"></span><br><span class="line">    // unload the triangle library</span><br><span class="line">    dlclose(triangle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>polygon.cpp  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#ifndef POLYGON_HPP</span><br><span class="line">#define POLYGON_HPP</span><br><span class="line"></span><br><span class="line">class polygon &#123;</span><br><span class="line">protected:</span><br><span class="line">    double side_length_;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    polygon() : side_length_(0) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    virtual ~polygon() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    void set_side_length(double side_length) &#123;</span><br><span class="line">        side_length_ = side_length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    virtual double area() const = 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// the types of the class factories</span><br><span class="line">typedef polygon* create_t();</span><br><span class="line">typedef void destroy_t(polygon*);</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>triangle.cpp:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;polygon.hpp&quot;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">class triangle : public polygon &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual double area() const &#123;</span><br><span class="line">        return side_length_ * side_length_ * sqrt(3) / 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// the class factories</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; polygon* create() &#123;</span><br><span class="line">    return new triangle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; void destroy(polygon* p) &#123;</span><br><span class="line">    delete p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当加载类时需要注意以下几点：  </p>
<p><li>你必须同时提供创建以及销毁函数；千万不要在可执行文件中通过delete销毁实例，而是将它回传给模块。这主要是因为在C++中new和delete可能被重载；这样会导致非匹配的new和delete被调用，由此可能会导致内存泄漏以及段错误。</li>  </p>
<p><li>任何情况下接口类的销毁函数都应该是需函数。可能在某些罕见情况下这个是不必要的，但并不值得冒险，而且额外的开销通常可以忽略。</li><br>即使你的基类不需要销毁函数，也最好定义一个空销毁函数，否则你迟早会遇到问题。  </p>
</div><!-- comment system--><div class="container"><hr><div data-thread-key="2016/09/16/20160916/" data-title="dlsym加载动态链接库进阶使用" data-url="https://dcant.github.io/2016/09/16/20160916/" class="ds-thread"></div><script>var duoshuoQuery = {short_name:'dcant'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script></div></article><footer id="footer"><div class="container"><div class="bar"><div class="social"><a href="http://weibo.com/twtlove" target="_blank"><i class="fa fa-weibo"></i></a><a href="https://github.com/dcant" target="_blank"><i class="fa fa-github"></i></a></div><div class="footer">© 2016 <a href="/" rel="nofollow">Talk is cheap, but I need it.</a>. Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo</a>. Theme <a target="_blank" href="https://github.com/lotabout/very-simple">very-simple</a>.</div></div></div></footer><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>